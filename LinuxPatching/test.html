<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>test.html</title>
        <style type="text/css">
          .end-element { fill : #FFCCFF; }
        </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.3.0/raphael.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.17.1/flowchart.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.1/js/bootstrap.bundle.min.js"></script>
        <!-- <script src="../release/flowchart.min.js"></script> -->
        <script>

            window.onload = function () {
                var btn = document.getElementById("run"),
                    cd = document.getElementById("code"),
                    chart;
                    
                (btn.onclick = function () {
                    var code = cd.value;

                    if (chart) {
                      chart.clean();
                    }

                    chart = flowchart.parse(code);
                    chart.drawSVG('canvas', {
                      'x': 0,
                      'y': 0,
                      'line-width': 3,
                      //'maxWidth': 15,//ensures the flowcharts fits within a certain width
                      'line-length': 50,
                      'text-margin': 10,
                      'font-size': 14,
                      'font': 'normal',
                      'font-family': 'Helvetica',
                      'font-weight': 'normal',
                      'font-color': 'black',
                      'line-color': 'black',
                      'element-color': 'black',
                      'fill': 'white',
                      'yes-text': 'yes',
                      'no-text': 'no',
                      'arrow-end': 'block',
                      'scale': 1,
                      'symbols': {
                        'start': {
                          'font-size': 14,
                          'font-color': 'yellow',
                          'element-color': 'blue',
                          'fill': 'green',
                          'class': 'start-element'
                        },
                        'inputoutput': {
                          'font-color': 'black',
                          'element-color': 'black',
                          'fill': 'bisque'
                        },
                        'operation': {
                          'font-color': 'black',
                          'element-color': 'black',
                          'fill': 'linen'
                        },
                        'subroutine': {
                          'font-color': 'black',
                          'element-color': 'blue',
                          'fill': 'lightgreen'
                        },
                        'condition': {
                          'font-color': 'red',
                          'element-color': 'black',
                          'fill': 'yellow'
                        },
                        'end':{
                          'font-size': 20,
                          'class': 'end-element'
                        }
                      },
                      'flowstate' : {
                        //'past' : { 'fill' : '#CCCCCC', 'font-size' : 12},
                        //'current' : {'fill' : 'yellow', 'font-color' : 'red', 'font-weight' : 'bold'},
                        //'future' : { 'fill' : '#FFFF99'},
                        'request' : { 'fill' : 'blue'},
                        'invalid': {'fill' : '#444444'},
                        'approved' : { 'fill' : '#58C4A3', 'font-size' : 12, 'yes-text' : 'APPROVED', 'no-text' : 'n/a' },
                        'rejected' : { 'fill' : '#C45879', 'font-size' : 12, 'yes-text' : 'n/a', 'no-text' : 'REJECTED' }
                      }
                    });
                    //create base64 encoding of SVG to generate download link for title(without html or htm).SVG
                    var currentCanvasDIV = document.getElementById('canvas')
                    var currentDrawSVG = currentCanvasDIV.innerHTML.replaceAll('ë','e');

                    const OUTsvgBASE64 = btoa(currentDrawSVG)
                    doctitle = document.title.replace('.html','');
                    doctitle = doctitle.replace('.htm','');


                    var currentCanvasDIV = document.getElementById('canvas')
                    var currentDrawSVG = currentCanvasDIV.innerHTML.replaceAll('ë','e');
                    svgSource = currentDrawSVG
                    svgXML = currentDrawSVG;
                    // Use SVG Height and Width from the SVG XML to set canvas size
                    svgXMLsubstringHeight = svgXML.substring(svgXML.indexOf('height='), svgXML.indexOf('version='));
                    svgXMLsubstringWidth = svgXML.substring(svgXML.indexOf('width='), svgXML.indexOf('xmlns='));
                    HeightValue = svgXMLsubstringHeight.substring(svgXMLsubstringHeight.indexOf('"')+1,svgXMLsubstringHeight.lastIndexOf('"'));
                    WidthValue = svgXMLsubstringWidth.substring(svgXMLsubstringWidth.indexOf('"')+1,svgXMLsubstringWidth.lastIndexOf('"'));
                    HeightValueInt = Math.round(HeightValue)
                    WidthValueInt = Math.round(WidthValue)
                    // setup input for base64SvgToBase64Png
                    let svgSrc = "data:image/svg+xml;base64,"+OUTsvgBASE64;
                    var pngBase
                    imageUtil.base64SvgToBase64Png(svgSrc, WidthValueInt, HeightValueInt).then(pngSrc => {
                    pngBase = pngSrc
                    // output download link for base64 PNG converted on download from base64
                    var pngOutHtml = `<a href="${pngBase}" download="${doctitle}.png">PNG - Click here to download current rendered flowchart as ${doctitle}.png</a>`
                    document.getElementById("pngbase64").innerHTML=pngOutHtml;
                    });    
                    // output download link for base64 SVG converted on download from base64
                    var svgOutHtml = `<a href="data:image/svg+xml;base64,${OUTsvgBASE64}" download=${doctitle}.svg>SVG - Click here to download current rendered flowchart as ${doctitle}.svg</a> `
                        document.getElementById("svgbase64").innerHTML=svgOutHtml;
                    })();

                            };
                 

// derived from https://stackoverflow.com/a/64800570
// we need to use web browser canvas to generate a image. In this case png
let imageUtil = {};
/**
 * converts a base64 encoded data url SVG image to a PNG image
 * @param originalBase64 data url of svg image
 * @param width target width in pixel of PNG image
 * @param secondTry used internally to prevent endless recursion
 * @return {Promise<unknown>} resolves to png data url of the image
 */
imageUtil.base64SvgToBase64Png = function (originalBase64, width, height, secondTry) {
    return new Promise(resolve => {
        let img = document.createElement('img');
        img.onload = function () {
            if (!secondTry && (img.naturalWidth === 0 || img.naturalHeight === 0)) {
                let svgDoc = base64ToSvgDocument(originalBase64);
                let fixedDoc = fixSvgDocumentFF(svgDoc);
                return imageUtil.base64SvgToBase64Png(svgDocumentToBase64(fixedDoc), width, height, true).then(result => {
                    resolve(result);
                });
            }
            //document.body.appendChild(img);
            let canvas2 = document.createElement("canvas");
            //document.body.removeChild(img);
            canvas2.width = width;
            canvas2.height = height;
            let ctx = canvas2.getContext("2d");
            ctx.drawImage(img, 0, 0, canvas2.width, canvas2.height);
            try {
                let data = canvas2.toDataURL('image/png');
                resolve(data);
            } catch (e) {
                resolve(null);
            }
        };
        img.src = originalBase64;
    });
}

//needed because Firefox doesn't correctly handle SVG with size = 0, see https://bugzilla.mozilla.org/show_bug.cgi?id=700533
function fixSvgDocumentFF(svgDocument) {
    try {
        let widthInt = parseInt(svgDocument.documentElement.width.baseVal.value) || 500;
        let heightInt = parseInt(svgDocument.documentElement.height.baseVal.value) || 500;
        svgDocument.documentElement.width.baseVal.newValueSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX, widthInt);
        svgDocument.documentElement.height.baseVal.newValueSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX, heightInt);
        return svgDocument;
    } catch (e) {
        return svgDocument;
    }
}

function svgDocumentToBase64(svgDocument) {
    try {
        let base64EncodedSVG = btoa(new XMLSerializer().serializeToString(svgDocument));
        return 'data:image/svg+xml;base64,' + base64EncodedSVG;
    } catch (e) {
        return null;
    }
}

function base64ToSvgDocument(base64) {
    let svg = atob(base64.substring(base64.indexOf('base64,') + 7));
    svg = svg.substring(svg.indexOf('<svg'));
    let parser = new DOMParser();
    return parser.parseFromString(svg, "image/svg+xml");
} 
        </script>

        <script>
            function HelpText() {
              var x = document.getElementById("HelpTextBlock");
              if (x.style.display === "none") {
                x.style.display = "block";
              } else {
                x.style.display = "none";
              }
            }
        </script>
    </head>
    <body>
        <div><textarea id="code" style="width: 100%;" rows="11">op2=>operation: import os
op4=>operation: import argparse
op6=>operation: import subprocess
op8=>operation: import json
op10=>operation: import logging
op12=>operation: import subprocess
op14=>operation: from datetime import datetime
op16=>operation: import sys
op18=>operation: import re
op20=>operation: class CriticalSubprocessError(Exception):
    pass
op22=>operation: class PrePatchCheck():

    def __init__(self, changeNumber):
        try:
            self.initialize_variables(changeNumber)
            self.run_pre_patch_checks()
            self.log_initial_state()
            self.generate_report()
            self.load_config()
            self.setup_logging_and_output_paths()
            self.check_disk_space()
            self.log(f'Start time: {self.startTime}')
            self.log('Starting pre-patch check')
            self.log(f'Change number: {self.changeNumber}')
            self.log(f'Kernel versions: {self.kernelVersions}')
            self.log(f'Valid repositories: {self.validRepositories}')
            self.log(f'Package manager: {self.packageManager}')
            self.log(f'Output directory: {self.outputDirectory}')
            self.log(f'Debug log filepath: {self.debugLogFilepath}')
            self.log(f'Pre-patch report filepath: {self.prePatchReportFilepath}')
            self.log(f'CSV output: {self.csvOutput}')
            self.log(f'Instance ID: {self.get_instanceId()}')
            self.log(f'OS type: {self.identify_os()}')
            self.log(f'Kernel packages: {self.get_kernelPackages()}')
            self.log(f'Available kernels: {self.get_available_kernels()}')
            self.log(f'New kernel version: {self.get_newKernelVersion()}')
            self.log(f'CrowdStrike version: {self.get_crowdstrikeVersion()}')
            self.log(f'RFM state: {self.get_rfmState()}')
            self.log(f'Disk space: {self.check_disk_space()}')
            self.log(f'Manual intervention required: {self.manualInterventionRequired}')
            self.log(f'Failed functions: {self.failedFunctions}')
            self.log(f'End time: {datetime.now()}')
            self.log(f'Elapsed time: {(datetime.now() - self.startTime)}')
            self.log('Pre-patch check completed')
            self.stage_patch_script()
        except CriticalSubprocessError:
            self.update_critical_failure_report()
            sys.exit(1)

    def initialize_variables(self, changeNumber):
        self.changeNumber = changeNumber
        self.kernelVersions = {}
        self.validRepositories = []
        self.startTime = datetime.now()
        self.failedFunctions = []
        self.packageManager = 'dnf'
        self.manualInterventionNeeded = False
        self.outputDirectory = ''
        self.debugLogFilepath = ''
        self.prePatchReportFilepath = ''
        self.csvOutput = []
        self._instanceId = None
        self._newKernelVersion = None
        self._kernelPackages = None
        self._crowdstrikeVersion = None
        self._rfmState = None
        self.failedChecks = []

    def log_initial_state(self):
        self.log(f'Start time: {self.startTime}')
        self.log('Starting pre-patch check')
        self.log('Pre-patch check completed')

    def run_pre_patch_checks(self):
        self.log('Starting pre-patch checks...')
        if (not self.load_config()):
            self.log('Failed to load configurations. Exiting.')
            return False
        if (not self.setup_logging_and_output_paths()):
            self.log('Failed to set up logging and output paths. Exiting.')
            return False
        if (not self.check_disk_space()):
            self.log('Disk space check failed. Exiting.')
            return False
        os_type = self.identify_os()
        if (os_type == 'Unknown'):
            self.log('Failed to identify OS type. Exiting.')
            return False
        instance_id = self.get_instanceId()
        if (instance_id == 'Unknown'):
            self.log('Failed to fetch instance ID. Exiting.')
            return False
        kernel_packages = self.get_kernelPackages()
        if (kernel_packages is None):
            self.log('Failed to fetch kernel packages. Exiting.')
            return False
        available_kernels = self.get_available_kernels()
        if (not available_kernels):
            self.log('Failed to fetch available kernels. Exiting.')
            return False
        new_kernel_version = self.get_newKernelVersion()
        if (new_kernel_version is None):
            self.log('Failed to fetch new kernel version. Exiting.')
            return False
        crowdstrike_version = self.get_crowdstrikeVersion()
        if ((crowdstrike_version == 'CrowdStrike not installed') or (crowdstrike_version == 'CrowdStrike error')):
            self.log('Failed to fetch CrowdStrike version. Exiting.')
            return False
        rfm_state = self.get_rfmState()
        if (rfm_state == 'Error'):
            self.log('Failed to fetch RFM state. Exiting.')
            return False
        self.log('Pre-patch checks completed successfully.')
        return True

    def load_config(self):
        self.log('Loading configurations...')
        cmd = ['curl', 'https://linux-kernels.s3-us-gov-west-1.amazonaws.com/linux-kernels.json']
        self.log(f"Executing command: {' '.join(cmd)}")
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            config_data = result.stdout
        except subprocess.CalledProcessError:
            self.log('Failed to fetch configurations from the URL.')
            self.update_prepatch_report('Manual Intervention Required: Failed to download linux-kernels.json')
            self.manualInterventionRequired = True
            return
        except Exception as e:
            self.log(f'An unexpected error occurred while executing the command: {e}')
            self.manualInterventionRequired = True
            return
        try:
            data = json.loads(config_data)
            self.kernelVersions = data.get('kernel_list', {})
            self.validRepositories = data.get('valid_repos', [])
        except json.JSONDecodeError:
            self.log('Failed to parse the fetched configurations as JSON.')
            self.update_prepatch_report('Manual Intervention Required: JSON ERROR')
            self.manualInterventionRequired = True
        except Exception as e:
            self.log(f'An unexpected error occurred while parsing the JSON data: {e}')
            self.manualInterventionRequired = True

    def setup_logging_and_output_paths(self):
        self.outputDirectory = os.path.join('/root', self.changeNumber)
        self.debugLogFilepath = os.path.join(self.outputDirectory, 'debug.log')
        self.prePatchReportFilepath = os.path.join(self.outputDirectory, 'pre-patch.report')
        os.makedirs(self.outputDirectory, exist_ok=True)
        logging.basicConfig(filename=self.debugLogFilepath, level=logging.DEBUG)
        open(self.debugLogFilepath, 'w').close()
        open(self.prePatchReportFilepath, 'w').close()

    def log(self, message):
        'Log messages with a timestamp.'
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        logging.debug('{}: {}'.format(timestamp, message))

    def subprocess_output(self, cmd):
        self.log(f"Executing command: {' '.join(cmd)}")
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            output = result.stdout.strip()
            self.log(f'Command output: {output}')
            return output
        except subprocess.CalledProcessError as e:
            self.log(f'Command failed with return code: {e.returncode}. Error: {e.stderr}')
            raise CriticalSubprocessError('Command execution failed.')
        except Exception as e:
            self.log(f'Error executing command: {e}')
            raise CriticalSubprocessError('Unexpected error during command execution.')

    def update_critical_failure_report(self):
        with open(self.prePatchReportFilepath, 'w') as f:
            f.write('Critical Python Failure. Check logs for details.')

    def get_instanceId(self):
        if self._instanceId:
            return self._instanceId
        instance_id = self.subprocess_output(['curl', '-s', 'http://169.254.169.254/latest/meta-data/instance-id'])
        if instance_id:
            self.log('Instance id: {}'.format(instance_id))
            return instance_id
        else:
            self.log('Error fetching instance ID.')
            self.manualInterventionRequired = True
            self.failedFunctions.append('get_instanceId')
            return 'Unknown'

    def identify_os(self):
        try:
            if os.path.isfile('/etc/redhat-release'):
                with open('/etc/redhat-release', 'r') as file:
                    release_info = file.read()
                    if ('Fedora' in release_info):
                        self.osType = 'Fedora'
                    else:
                        self.osType = 'RHEL/CentOS'
            elif os.path.isfile('/etc/system-release'):
                with open('/etc/system-release', 'r') as file:
                    release_info = file.read()
                    if ('Amazon Linux release 2' in release_info):
                        self.osType = 'AWSLinux2'
                    elif ('Amazon Linux release 2022' in release_info):
                        self.osType = 'AWSLinux2022'
                    else:
                        raise ValueError('Unexpected content in /etc/system-release.')
            else:
                raise FileNotFoundError('OS identification files not found.')
        except (IOError, PermissionError) as e:
            self.log(f'Error reading OS identification file: {e}')
            self.osType = 'Unknown'
        except ValueError as e:
            self.log(str(e))
            self.osType = 'Unknown'
        except Exception as e:
            self.log(f'Unexpected error in identify_os: {e}')
            self.osType = 'Unknown'
            self.manualInterventionRequired = True
            self.failedFunctions.append('identify_os')
        return self.osType

    def check_disk_space(self):
        try:
            stat = os.statvfs('/var')
            free_space_gb = ((stat.f_frsize * stat.f_bavail) / ((1024 * 1024) * 1024))
            self.csvOutput.append(f'{free_space_gb:.2f} GB')
            if (free_space_gb < 2):
                self.failedChecks.append('Disk space less than 2GB')
                return False
            return True
        except OSError as e:
            self.log(f'File system error when checking disk space: {e}')
            self.failedChecks.append(f'Disk space check failed due to error: {e}')
            self.csvOutput.append('N/A')
            return False
        except Exception as e:
            self.log(f'Unexpected error in check_disk_space: {e}')
            self.failedChecks.append(f'Disk space check failed due to error: {e}')
            self.csvOutput.append('N/A')
            return False

    def validate_repos(os_version):
        with open('linux-kernels.json', 'r') as file:
            data = json.load(file)
        valid_repos = data['valid_repos'].get(os_version, [])
        non_valid_repos = data['non-valid_repos']
        try:
            result = subprocess.run(['yum', 'repo', 'list', 'enabled'], capture_output=True, text=True)
            enabled_repos = result.stdout.splitlines()
        except Exception as e:
            print(f'Error getting list of enabled repositories: {e}')
            return
        non_standard_repos = []
        disabled_repos = []
        for repo in non_valid_repos:
            if any((r.startswith(repo) for r in enabled_repos)):
                try:
                    subprocess.run(['yum-config-manager', '--disable', f'{repo}*'], check=True)
                    print(f'Disabled non-valid repo: {repo}')
                    disabled_repos.append(repo)
                except Exception as e:
                    print(f'Error disabling non-valid repo {repo}: {e}')
        for repo in enabled_repos:
            if ((repo not in valid_repos) and (not any((r.startswith(repo) for r in non_valid_repos)))):
                non_standard_repos.append(repo)
        if non_standard_repos:
            print(f"Warning Non-Standard Repos enabled: {' '.join(non_standard_repos)}")
        elif (not disabled_repos):
            print('PrePatchReport: Pass')
        else:
            print(f"PrePatchReport: Pass - Non Valid Repos disabled: {' '.join(disabled_repos)}")
    validate_repos('rhel_8')

    def get_newKernelVersion(self):
        if self._newKernelVersion:
            return self._newKernelVersion
        try:
            os_version = self.osType
            desired_kernel_version = self.kernelVersions.get(os_version)
            available_kernels = self.get_available_kernels()
            if (desired_kernel_version not in available_kernels):
                self.log(f'Desired kernel version {desired_kernel_version} not found in available kernels.')
                self.manualInterventionRequired = True
                self.failedFunctions.append('get_newKernelVersion')
                return None
            return desired_kernel_version
        except Exception as e:
            self.log(f'Error in get_newKernelVersion: {e}. Please check the syntax of the linux-kernels.json file.')
            self.manualInterventionRequired = True
            self.failedFunctions.append('get_newKernelVersion')

    def get_available_kernels(self):
        self.log('Fetching available kernels')
        try:
            result = subprocess.run([self.packageManager, 'list', 'available', 'kernel*'], capture_output=True, text=True, check=True)
            available_kernels = result.stdout.strip().split('\n')
            self.log(f'Available kernels: {available_kernels}')
            return available_kernels
        except subprocess.CalledProcessError as e:
            self.log(f'Error fetching available kernels: {e.stderr}')
            self.update_prepatch_report('Manual Intervention Required: Failed to fetch available kernels.')
            self.manualInterventionRequired = True
            return []
        except Exception as e:
            self.log(f'Unexpected error fetching available kernels: {e}')
            self.update_prepatch_report('Manual Intervention Required: Unexpected error while fetching available kernels.')
            self.manualInterventionRequired = True
            return []

    def get_kernelPackages(self):
        if self._kernelPackages:
            return self._kernelPackages
        self.log('Fetching kernel packages for RHEL/CentOS, AWSLinux2, and AWSLinux2022')
        try:
            result = subprocess.run([self.packageManager, 'list', 'updates', 'kernel*'], capture_output=True, text=True, check=True)
            kernel_packages = result.stdout.strip()
            if (not kernel_packages):
                self.log('No kernel packages available for update.')
                return None
            self.log('Kernel packages: {}'.format(kernel_packages))
            return kernel_packages
        except subprocess.CalledProcessError as e:
            self.log(f'Error fetching kernel packages: {e.stderr}')
            self.manualInterventionRequired = True
            self.failedFunctions.append('get_kernelPackages')
            return None
        except Exception as e:
            self.log(f'Unexpected error in get_kernelPackages: {e}')
            self.manualInterventionRequired = True
            self.failedFunctions.append('get_kernelPackages')
            return None

    def get_crowdstrikeVersion(self):
        self.log('Fetching CrowdStrike version')
        if (not os.path.exists('/opt/CrowdStrike/')):
            self.log('CrowdStrike directory not found. Crowdstrike does not appear to be installed.')
            self.update_prepatch_report('Manual intervention - Crowdstrike does not appear to be installed')
            return 'CrowdStrike not installed'
        try:
            result = subprocess.run(['/opt/CrowdStrike/falconctl', '-g', '--version'], capture_output=True, text=True, check=True)
            crowdstrike_version = result.stdout.strip()
            self.log('CrowdStrike version: {}'.format(crowdstrike_version))
            return crowdstrike_version
        except subprocess.CalledProcessError as e:
            self.log(f'Error fetching CrowdStrike version. Error: {e.stderr}')
            self.log('Checking if the CrowdStrike service is running.')
            service_status = subprocess.run(['systemctl', 'status', 'falcon-sensor'], capture_output=True, text=True)
            self.log(f'CrowdStrike service status: {service_status.stdout}')
            if ('inactive' in service_status.stdout):
                self.log('CrowdStrike service is not running. Attempting to start it.')
                try:
                    subprocess.run(['systemctl', 'start', 'falcon-sensor'], check=True)
                    self.log('CrowdStrike service started successfully.')
                    time.sleep(2)
                except subprocess.CalledProcessError as e:
                    self.log(f'Failed to start CrowdStrike service. Error: {e.stderr}')
                    self.update_prepatch_report('Manual remediation - Failed to start CrowdStrike service')
                    return 'CrowdStrike error'
            try:
                result = subprocess.run(['/opt/CrowdStrike/falconctl', '-g', '--version'], capture_output=True, text=True, check=True)
                crowdstrike_version = result.stdout.strip()
                self.log('CrowdStrike version after service restart: {}'.format(crowdstrike_version))
                return crowdstrike_version
            except subprocess.CalledProcessError as e:
                self.log('Error fetching CrowdStrike version even after restarting the service. Error: {}'.format(e.stderr))
                self.update_prepatch_report('Manual remediation - Crowdstrike Error')
                return 'CrowdStrike error'
        except Exception as e:
            self.log(f'Unexpected error in get_crowdstrikeVersion: {e}')
            self.update_prepatch_report('Manual remediation - Unexpected error in get_crowdstrikeVersion')
            return 'CrowdStrike error'

    def get_rfmState(self):
        if (not self._crowdstrikeVersion):
            self.log('CrowdStrike version not found. Skipping RFM state check.')
            self.failedFunctions.append('get_rfmState')
            return 'Unknown'
        self.log('Fetching RFM state')
        cmd = ['/opt/CrowdStrike/falconctl', '-g', '--rfm-state']
        try:
            rfm_state = self.subprocess_output(cmd)
            self.log(f'RFM state: {rfm_state}')
            if (rfm_state == 'True'):
                self.log('RFM state is True. Kernel is out of alignment with Crowdstrike.')
                self.update_prepatch_report('Manual Remediation - Kernel out of alignment with Crowdstrike. RFM state True')
                self.manualInterventionRequired = True
                return 'RFM True'
            return rfm_state
        except CriticalSubprocessError:
            self.log('Error fetching RFM state. Check if CrowdStrike is properly installed and running.')
            self.manualInterventionRequired = True
            self.failedFunctions.append('get_rfmState')
            return 'Error'

    def dry_run_patch(self):
        self.log('Starting dry-run for kernel update')
        new_kernel_version = self.get_newKernelVersion()
        patchme_file = f'/root/{self.changeNumber}/patchme.sh'
        with open(patchme_file, 'w') as f:
            f.write('#!/bin/bash\n')
            f.write(f'''newkernel="{new_kernel_version}"
''')
            f.write('yum --assumeno install $(while read p; do printf "$p-$newkernel "; done < /root/{self.changeNumber}/kernel_packages)\n')
            f.write('yum --assumeno --security --exclude=kernel* update\n')
        try:
            result = subprocess.run(['bash', patchme_file])
            if (result.returncode != 0):
                self.log('Dry-run failed')
                self.manualInterventionRequired = True
                self.failedFunctions.append('dry_run_patch')
                self.update_prepatch_report('Manual Intervention Required - Dry Run Fail')
                return False
            return True
        except Exception as e:
            self.log(f'Error in dry_run_patch: {e}')
            self.manualInterventionRequired = True
            self.failedFunctions.append('dry_run_patch')
            self.update_prepatch_report('Manual Intervention Required - Unknown Error')
            return False

    def stage_patch_script(self):
        patchme_file = f'/root/{self.changeNumber}/patchme.sh'
        with open(patchme_file, 'r') as f:
            content = f.read().replace('--assumeno', '-y')
        with open(patchme_file, 'w') as f:
            f.write(content)
        os.chmod(patchme_file, 493)
        self.update_prepatch_report('patchme.sh is executable')

    def generate_report(self):
        self.log('Generating report')
        qc_pass_status = ('PASS' if (not self.manualInterventionRequired) else f"FAIL on {', '.join(self.failedFunctions)}")
        with open(self.prePatchReportFilepath, 'w') as f:
            f.write('instance_id,os_version,NewKernelVersion,available_kernels,kernel_packages,crowdstrike_version,rfm_state,/var_space_GB,script_startTime,script_end_time,intervention_required,QC Pass\n')
            f.write('{},{},{},{},{},{},{},{},{},{},{},{}'.format(self.get_instanceId(), self.identify_os(), self.get_newKernelVersion(), self.get_available_kernels(), self.get_kernelPackages(), self.get_crowdstrikeVersion(), self.get_rfmState(), self.csvOutput[(- 1)], self.startTime, datetime.now(), ('Manual Intervention Required' if self.manualInterventionRequired else 'No intervention required'), qc_pass_status))
        self.log('Report generated')
cond25=>condition: if (__name__ == '__main__')
op29=>operation: changeNumber = os.environ.get('CHANGE_NUMBER')
cond32=>condition: if (not changeNumber)
sub36=>subroutine: print('CHANGE_NUMBER environment variable not set.')
sub38=>subroutine: sys.exit(1)
op43=>operation: check = PrePatchCheck(changeNumber)
op45=>operation: rfm_state = check.get_rfmState()
cond48=>condition: if (rfm_state != 'RFM True')
cond53=>operation: check.stage_patch_script() if  check.dry_run_patch()
sub65=>subroutine: check.log('Skipping dry_run_patch due to RFM state being True.')

op2->op4
op4->op6
op6->op8
op8->op10
op10->op12
op12->op14
op14->op16
op16->op18
op18->op20
op20->op22
op22->cond25
cond25(yes)->op29
op29->cond32
cond32(yes)->sub36
sub36->sub38
sub38->op43
op43->op45
op45->cond48
cond48(yes)->cond53
cond48(no)->sub65
cond32(no)->op43
</textarea></div>
        <div><button id="run" type="button">Run</button> <button onclick="HelpText()">Format Help</button></div>
        <div id="HelpTextBlock" style="display:none"><br/>Conditions can also be redirected like cond(yes, bottom) or cond(yes, right)
... and the other symbols too... like sub1(right)<br/>
You can also tweak the <b>diagram.drawSVG('diagram', {});</b> script in this file for more changes<br/>
This is based on <a href="https://github.com/adrai/flowchart.js">flowchart.js on github</a> and <a href="http://flowchart.js.org">http://flowchart.js.org</a> more documentation can be found over there.
</div><br/><div id="svgbase64"></div>
        <div id="pngbase64"></div>

        <div id="canvas"></div>
    </body>
</html>